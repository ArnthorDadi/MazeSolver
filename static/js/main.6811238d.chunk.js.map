{"version":3,"sources":["Services/NodeService/NodeService.js","Components/Header/index.js","Services/MazeService/Walls.js","Solvers/Dijkstra/Dijkstra.js","Solvers/AstarSearch/AstarSearch.js","MazeGenerators/RecursiveBacktracker.js","Components/Menus/index.js","Components/Cell/index.js","Components/Maze/index.js","Services/MazeService/SolveMaze.js","Views/Home/index.js","reportWebVitals.js","index.js"],"names":["createCellNode","col","row","isStart","isFinish","isWall","createDijkstraNode","distance","Infinity","previousNode","isVisisted","createAstarNode","heuristic","fullDistance","Header","Title","this","props","AppBar","position","Toolbar","Typography","variant","align","style","marginRight","Component","getNewGridWithWallToggled","grid","newGrid","slice","node","newNode","helperHandleMouseEnter","mouseIsPressed","require","getDijkstraNodesInShortestPathOrder","finish","nodesInShortestPathOrder","currentNode","unshift","dijkstra","start","orderedVisitedNodes","dijkstrasGrid","startNode","dijkstraGrid","dijkstraRow","dijkstraNode","push","getDijkstraGrid","unvisitedNodes","dijkstraNodes","getNodes","length","minDistNode","findClosestNode","stripExtraData","isVisited","updateUnvisitedNeighbors","nodes","returnNodes","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","sort","nodeA","nodeB","shift","astar","astartGrid","astarGrid","astarRow","astarNode","getAStarGrid","getHeuristicScore","visitiedNodes","closestNode","newArray","updateNeighbors","getNeighbors","includes","currDistance","xOne","xTwo","yOne","yTwo","Math","abs","recursiveBacktracker","lineOfCells","cell","closeAllWallsAndUnvisistNodes","visitedNodesInOrder","nodeStack","pop","randomNeighbor","floor","random","openWall","console","log","undefined","useStyles","makeStyles","theme","root","display","paper","spacing","MenuTitle","color","Menus","MenuName","Options","SelectedIndex","changeSelectedOption","classes","React","useState","open","setOpen","anchorRef","useRef","handleClose","event","current","contains","target","handleListKeyDown","key","preventDefault","prevOpen","useEffect","focus","className","Button","ref","onClick","Popper","anchorEl","role","transition","disablePortal","TransitionProps","placement","Grow","transformOrigin","Paper","ClickAwayListener","onClickAway","MenuList","autoFocusItem","id","onKeyDown","map","option","index","MenuItem","selected","handleMenuItemClick","Cell","onMouseDown","onMouseEnter","onMouseUp","extraClassName","getInitialGrid","currentRow","Maze","solveMaze","state","startCell","finishCell","selectedSolver","clearClasses","result","solver","nodeVisisted_finish","visistedNodes","shortestPath","getSolvedMazePath","animateSolver","setState","solvedClass","createMaze","clearMaze","cellRow","document","getElementById","handleMouseDown","results","helperHandleMouseDown","handleMouseEnter","handleMouseUp","changeSolver","newSolverId","Solvers","selectedSolverId","HEIGHT","WIDTH","i","setTimeout","animateShortestPath","marginLeft","rowIdx","nodeIdx","Home","solvers","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render"],"mappings":"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","file":"static/js/main.6811238d.chunk.js","sourcesContent":["export function createCellNode(col, row, isStart, isFinish, isWall){\r\n    return {\r\n        col: col,\r\n        row: row,\r\n        isStart: isStart,\r\n        isFinish: isFinish,\r\n        isWall: isWall,\r\n      };\r\n};\r\n\r\nexport function createDijkstraNode(col, row, isStart, isFinish, isWall, distance = Infinity){\r\n    return {\r\n        col: col,\r\n        row: row,\r\n        isStart: isStart,\r\n        isFinish: isFinish,\r\n        isWall: isWall,\r\n        distance: distance,\r\n        previousNode: null,\r\n        isVisisted: false\r\n      };\r\n};\r\n\r\nexport function createAstarNode(col, row, isStart, isFinish, isWall, distance=Infinity, heuristic=null, fullDistance=null){\r\n  return {\r\n      col: col,\r\n      row: row,\r\n      isStart: isStart,\r\n      isFinish: isFinish,\r\n      isWall: isWall,\r\n      isVisisted: false,\r\n      previousNode: null,\r\n      distance: distance,\r\n      heuristic: heuristic,\r\n      fullDistance: fullDistance,\r\n    };\r\n};","import React, {Component} from 'react';\r\nimport AppBar from '@material-ui/core/AppBar';\r\nimport Toolbar from '@material-ui/core/Toolbar';\r\nimport Typography from '@material-ui/core/Typography';\r\n\r\nclass Header extends Component {\r\n\r\n  render() {\r\n    const {Title} = this.props;\r\n\r\n    return (\r\n      <div>\r\n      <AppBar position=\"static\">\r\n        <Toolbar>\r\n          <Typography variant=\"h6\" align=\"left\">\r\n            <div style={{ marginRight: '50px' }}>\r\n              {Title}\r\n            </div>\r\n          </Typography>\r\n        </Toolbar>\r\n      </AppBar>\r\n    </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Header;","export function getNewGridWithWallToggled(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n\r\nexport function helperHandleMouseDown(row, col, grid){\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n    return {\r\n        grid: newGrid,\r\n        mouseIsPressed: true\r\n    };\r\n};\r\n\r\nexport function helperHandleMouseEnter(row, col, grid, mouseIsPressed){\r\n    if (!mouseIsPressed) return grid;\r\n    const newGrid = getNewGridWithWallToggled(grid, row, col);\r\n    return newGrid;\r\n};","const { createCellNode, createDijkstraNode } = require('../../Services/NodeService/NodeService');\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getDijkstraNodesInShortestPathOrder(finish) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finish;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n  \r\nexport function dijkstra(grid, start, finish)\r\n{\r\n    const orderedVisitedNodes = [];\r\n    let dijkstrasGrid = getDijkstraGrid(grid, start);\r\n\r\n    dijkstrasGrid[start.row][start.col].distance = 0;\r\n\r\n\r\n    let unvisitedNodes = getNodes(dijkstrasGrid);\r\n    \r\n    // While there are some unvisited nodes keep going\r\n    while(unvisitedNodes.length !== 0)\r\n    {\r\n        // Finds the vertex in unvisited nodes that has the min distance to finish node\r\n        var minDistNode = findClosestNode(unvisitedNodes);\r\n        // If we encounter a wall, we skip it.\r\n        if (minDistNode.isWall) \r\n            continue;\r\n        // If the closest node is at a distance of infinity,\r\n        // we must be trapped and should therefore stop.\r\n        if (minDistNode.distance === Infinity){\r\n            return [stripExtraData(orderedVisitedNodes), minDistNode];\r\n        }\r\n        // Mark the node as visited and set it to the unvisitedNodes\r\n        minDistNode.isVisited = true;\r\n        orderedVisitedNodes.push(minDistNode);\r\n        // If the closest node is the finish node we are done and can return orderedVisitedNodes\r\n        if (minDistNode.isFinish){\r\n            return [stripExtraData(orderedVisitedNodes), minDistNode];\r\n        }\r\n        // Lastly we update unvisited nodes, their distances and paths\r\n        updateUnvisitedNeighbors(minDistNode, dijkstrasGrid);\r\n    }\r\n    return [[], null]\r\n\r\n}\r\n\r\nfunction stripExtraData(nodes){\r\n    let returnNodes = [];\r\n    for (const node of nodes) {\r\n        const { col, row, isStart, isFinish, isWall } = node;\r\n        returnNodes.push(createCellNode(col, row, isStart, isFinish, isWall));\r\n    }\r\n    return returnNodes;\r\n}\r\n  \r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n    // Gets the up, down, left, right cells\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    // Adds one (thats the distance) to that neighbors distance.\r\n    // If we wanted to add a weights to nodes this will need to be refactored\r\n    for (const neighbor of unvisitedNeighbors) \r\n    {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n}\r\n  \r\n  function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) \r\n      neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) \r\n      neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) \r\n      neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) \r\n      neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function findClosestNode(unvisitedNodes) {\r\n    // Sorts after distance\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    // Gets the first element in the array\r\n    return unvisitedNodes.shift();\r\n  }\r\n  \r\n    function getNodes(grid, startNode) {\r\n        let dijkstraNodes = [];\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                dijkstraNodes.push(node);\r\n            }\r\n        }\r\n        return dijkstraNodes;\r\n    }\r\n\r\n    function getDijkstraGrid(grid, startNode){\r\n        let dijkstraGrid = [];\r\n        for (const row of grid) {\r\n            let dijkstraRow = [];\r\n            for (const node of row) {\r\n                const { col, row, isStart, isFinish, isWall } = node;\r\n                \r\n                let dijkstraNode = createDijkstraNode(col, row, isStart, isFinish, isWall);\r\n                dijkstraRow.push(dijkstraNode);\r\n            }\r\n            dijkstraGrid.push(dijkstraRow);\r\n        }\r\n        return dijkstraGrid;\r\n    }","const { createCellNode, createAstarNode } = require('../../Services/NodeService/NodeService');\r\nexport function astar(grid, start, finish){\r\n\r\n    let astartGrid = getAStarGrid(grid);\r\n\r\n    astartGrid[start.row][start.col].distance = 0;\r\n    astartGrid[start.row][start.col].heuristic = getHeuristicScore(astartGrid[start.row][start.col], finish);\r\n    astartGrid[start.row][start.col].fullDistance = 0 + astartGrid[start.row][start.col].heuristic;\r\n\r\n    let unvisitedNodes = [astartGrid[start.row][start.col]];\r\n    let visitiedNodes = [];\r\n\r\n    let currentNode = null;\r\n    while (unvisitedNodes.length > 0) {\r\n        currentNode = closestNode(unvisitedNodes);\r\n        \r\n        if (currentNode.isWall) continue;\r\n        \r\n        if (currentNode.distance === Infinity){\r\n            return [stripExtraData(visitiedNodes), currentNode];\r\n        }\r\n        \r\n        currentNode.isVisited = true;\r\n        visitiedNodes.push(currentNode);\r\n        \r\n        if (currentNode.isFinish){\r\n            return [stripExtraData(visitiedNodes), currentNode];\r\n        }\r\n\r\n        let newArray = unvisitedNodes.filter(node => node != currentNode);\r\n        unvisitedNodes = newArray;\r\n        \r\n        updateNeighbors(currentNode, unvisitedNodes, astartGrid, finish);\r\n    }\r\n}\r\n\r\nfunction closestNode(unvisitedNodes){\r\n    let closestNode = {fullDistance: Infinity};\r\n    for (let node of unvisitedNodes) {\r\n        if(node.fullDistance < closestNode.fullDistance)\r\n            closestNode = node;\r\n        else if(node.fullDistance == closestNode.fullDistance)\r\n        {\r\n            if(node.heuristic < closestNode.heuristic){\r\n                closestNode = node;\r\n            }\r\n        }\r\n    }\r\n    return closestNode;\r\n}\r\n\r\nfunction updateNeighbors(currentNode, unvisitedNodes, grid, finish){\r\n    let neighbors = getNeighbors(currentNode, grid);\r\n    for (let neighbor of neighbors) {\r\n        if(neighbor.isWall) continue;\r\n\r\n        if (!unvisitedNodes.includes(neighbor)) {\r\n            neighbor.distance = currentNode.distance + 1;\r\n            neighbor.heuristic = getHeuristicScore(neighbor, finish);\r\n            neighbor.fullDistance = neighbor.distance + neighbor.heuristic;\r\n            neighbor.previousNode = currentNode;\r\n\r\n            unvisitedNodes.push(neighbor);\r\n        } else {\r\n            let currDistance = currentNode.distance + 1;\r\n            if(currDistance < neighbor.distance){\r\n                neighbor.distance = currDistance\r\n                neighbor.fullDistance = neighbor.distance + neighbor.heuristic;\r\n                neighbor.previousNode = currentNode;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) \r\n        neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) \r\n        neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) \r\n        neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) \r\n        neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nfunction getHeuristicScore(neighbor, finish){\r\n    let xOne = neighbor.col;\r\n    let xTwo = finish.col;\r\n    let yOne = neighbor.row;\r\n    let yTwo = finish.row;\r\n\r\n    let xChange = Math.abs(xOne - xTwo);\r\n    let yChange = Math.abs(yOne - yTwo);\r\n\r\n    return (xChange + yChange);\r\n}\r\n\r\nfunction getAStarGrid(grid){\r\n    let astarGrid = [];\r\n    for (const row of grid) {\r\n        let astarRow = [];\r\n        for (const node of row) {\r\n            const { col, row, isStart, isFinish, isWall } = node;    \r\n            let astarNode = createAstarNode(col, row, isStart, isFinish, isWall);\r\n            astarRow.push(astarNode);\r\n        }\r\n        astarGrid.push(astarRow);\r\n    }\r\n    return astarGrid;\r\n}\r\n\r\nfunction stripExtraData(nodes){\r\n    let returnNodes = [];\r\n    for (const node of nodes) {\r\n        const { col, row, isStart, isFinish, isWall } = node;\r\n        returnNodes.push(createCellNode(col, row, isStart, isFinish, isWall));\r\n    }\r\n    return returnNodes;\r\n}","export function recursiveBacktracker(grid, start, finish){\r\n    closeAllWallsAndUnvisistNodes(grid);\r\n    var visitedNodesInOrder = [];\r\n    start.isVisited = true;\r\n    var nodeStack = [start];\r\n    var neighbors;\r\n    while(nodeStack.length > 0){\r\n        let currentNode = nodeStack.pop();\r\n        currentNode.isWall = false;\r\n        \r\n        visitedNodesInOrder.push(currentNode);\r\n        neighbors = getUnvisitedNeighbors(currentNode, grid);\r\n        \r\n        if(neighbors.length > 0){\r\n            nodeStack.push(currentNode);\r\n            let randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];\r\n            randomNeighbor.isVisited = true;\r\n            nodeStack.push(randomNeighbor);\r\n            openWall(currentNode, randomNeighbor, grid);\r\n        }\r\n    }\r\n    console.log(\"Done\");\r\n    return visitedNodesInOrder;\r\n    \r\n}\r\nfunction closeAllWallsAndUnvisistNodes(grid){\r\n    for(let lineOfCells of grid){\r\n        for(let cell of lineOfCells){\r\n            if(cell.col % 2 == 1 || cell.row % 2 == 1)\r\n                cell.isWall = true;\r\n            else\r\n                cell.isWall = true;\r\n            cell.isVisited = false;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid){\r\n    const {col, row} = node;\r\n    let neighbors = [];\r\n    // Up\r\n    if (row > 0){\r\n        neighbors.push(grid[row - 2][col]);\r\n    }\r\n    // Down\r\n    if (row < grid.length - 1){\r\n        neighbors.push(grid[row + 2][col]);\r\n    }\r\n    // Left\r\n    if (col > 0){\r\n        neighbors.push(grid[row][col - 2]);\r\n    }\r\n    // Right\r\n    if (col < grid[0].length - 1){\r\n        neighbors.push(grid[row][col + 2]);\r\n    }\r\n\r\n    if(neighbors.length == 0) return [];\r\n    return neighbors.filter(neighbor => {\r\n        if(neighbor == undefined)\r\n            return false;\r\n        else\r\n            return !neighbor.isVisited\r\n        });\r\n}\r\n\r\nfunction openWall(node, neighbor, grid){\r\n    const {col, row} = node;\r\n    // Up\r\n    if (row > 0){\r\n        if(grid[row - 2][col] === neighbor){\r\n            grid[row - 1][col].isWall = false;\r\n        }\r\n    }\r\n    // Down\r\n    if (row < grid.length - 1){\r\n        if(grid[row + 2][col] === neighbor){\r\n            grid[row + 1][col].isWall = false;\r\n        }\r\n    }\r\n    // Left\r\n    if (col > 0){\r\n        if(grid[row][col - 2] === neighbor){\r\n            grid[row][col - 1].isWall = false;\r\n        }\r\n    }\r\n    // Right\r\n    if (col < grid[0].length - 1){\r\n        if(grid[row][col + 2] === neighbor){\r\n            grid[row][col + 1].isWall = false;\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport { makeStyles } from '@material-ui/core/styles';\r\n\r\nimport MenuItem from '@material-ui/core/MenuItem';\r\nimport Button from '@material-ui/core/Button';\r\nimport ClickAwayListener from '@material-ui/core/ClickAwayListener';\r\nimport Grow from '@material-ui/core/Grow';\r\nimport Paper from '@material-ui/core/Paper';\r\nimport Popper from '@material-ui/core/Popper';\r\nimport MenuList from '@material-ui/core/MenuList';\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    display: 'flex',\r\n  },\r\n  paper: {\r\n    marginRight: theme.spacing(2),\r\n  },\r\n  MenuTitle: {\r\n    color: 'White'\r\n  }\r\n}));\r\n\r\nconst Menus = ({MenuName, Options, SelectedIndex, changeSelectedOption}) => {\r\n\r\n  const handleMenuItemClick = (event, index) => {\r\n    changeSelectedOption(index);\r\n    handleClose(event);\r\n  };\r\n\r\n  const classes = useStyles();\r\n  const [open, setOpen] = React.useState(false);\r\n  const anchorRef = React.useRef(null);\r\n\r\n  const handleToggle = () => {\r\n    setOpen((prevOpen) => !prevOpen);\r\n  };\r\n\r\n  const handleClose = (event) => {\r\n    if (anchorRef.current && anchorRef.current.contains(event.target))\r\n      return;\r\n    setOpen(false);\r\n  };\r\n\r\n  function handleListKeyDown(event) {\r\n    if (event.key === 'Tab') {\r\n      event.preventDefault();\r\n      setOpen(false);\r\n    }\r\n  }\r\n\r\n  // return focus to the button when we transitioned from !open -> open\r\n  const prevOpen = React.useRef(open);\r\n  React.useEffect(() => {\r\n    if (prevOpen.current === true && open === false) {\r\n      anchorRef.current.focus();\r\n    }\r\n\r\n    prevOpen.current = open;\r\n  }, [open]);\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <div>\r\n        <Button\r\n          className={classes.MenuTitle}\r\n          variant=\"contained\"\r\n          color=\"primary\"\r\n          ref={anchorRef}\r\n          onClick={handleToggle}>\r\n          {MenuName}\r\n        </Button>\r\n        <Popper open={open} anchorEl={anchorRef.current} role={undefined} transition disablePortal>\r\n          {({ TransitionProps, placement }) => (\r\n            <Grow\r\n              {...TransitionProps}\r\n              style={{ transformOrigin: placement === 'bottom' ? 'center top' : 'center bottom' }}>\r\n              <Paper>\r\n                <ClickAwayListener onClickAway={handleClose}>\r\n                  <MenuList autoFocusItem={open} id=\"menu-list-grow\" onKeyDown={handleListKeyDown}>\r\n                    {Options.map((option, index) => (\r\n                      <MenuItem\r\n                        key={option}\r\n                        selected={index === SelectedIndex}\r\n                        onClick={(event) => handleMenuItemClick(event, index) }>\r\n                        {option}\r\n                      </MenuItem>\r\n                    ))}\r\n                  </MenuList>\r\n                </ClickAwayListener>\r\n              </Paper>\r\n            </Grow>\r\n          )}\r\n        </Popper>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Menus;","import React, {Component} from 'react';\r\n\r\nimport './index.css';\r\n\r\nexport default class Cell extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      : isWall\r\n      ? 'node-wall'\r\n      : '';\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, {Component} from 'react';\r\nimport Button from '@material-ui/core/Button';\r\nimport { createCellNode } from '../../Services/NodeService/NodeService';\r\nimport { helperHandleMouseDown, helperHandleMouseEnter } from '../../Services/MazeService/Walls';\r\nimport { getSolvedMazePath } from '../../Services/MazeService/SolveMaze';\r\nimport { recursiveBacktracker } from '../../MazeGenerators/RecursiveBacktracker'; \r\n\r\nimport Menu from '../../Components/Menus';\r\nimport Cell from '../Cell';\r\n\r\nimport './index.css';\r\n\r\nconst HEIGHT = 25;\r\nconst WIDTH = 51;\r\n\r\nconst getInitialGrid = (start, finish) => {\r\n    let row_nr = HEIGHT;\r\n    let col_nr = WIDTH;\r\n    const grid = [];\r\n    for (let row = 0; row < row_nr; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < col_nr; col++) {\r\n            let isStart = false;\r\n            let isFinish = false;\r\n            if(row == start.row && col == start.col) isStart = true;\r\n            else if(row == finish.row && col == finish.col) isFinish = true;\r\n            currentRow.push(createCellNode(col, row, isStart, isFinish, false));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\nclass Maze extends Component {\r\n  \r\n\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            startCell: {row: 0, col: 0}, \r\n            finishCell: {row: HEIGHT-1, col: WIDTH-1},\r\n            grid: getInitialGrid({row: 0, col: 0}, {row: HEIGHT-1, col: WIDTH-1}),\r\n            mouseIsPressed: false,\r\n            solvedClass: false,\r\n            selectedSolverId: 0, \r\n            selectedSolver: ''\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const {Solvers} = this.props;\r\n        const {selectedSolverId} = this.state;\r\n        this.setState({\r\n            selectedSolver: Solvers[selectedSolverId]\r\n        });\r\n    }\r\n    \r\n    solveMaze = () => {\r\n        const {grid, startCell, finishCell, selectedSolver} = this.state;\r\n        this.clearClasses();\r\n        const result = getSolvedMazePath(grid, startCell, finishCell, selectedSolver);\r\n        this.animateSolver(result.visistedNodes, result.shortestPath);\r\n        this.setState({solvedClass: true});\r\n    }\r\n\r\n    createMaze = () => {\r\n        this.clearMaze();\r\n        const {grid, startCell, finishCell} = this.state;\r\n        recursiveBacktracker(grid, startCell, finishCell);\r\n        this.setState({grid});\r\n    }\r\n\r\n    /* Animations of shortest path */\r\n    animateSolver(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-visited';\r\n            }, 10 * i);\r\n        }\r\n    }\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                    'node node-shortest-path';\r\n            }, 50 * i);\r\n        }\r\n    }\r\n    /* ------------------- */\r\n    \r\n    /* Clear Maze */\r\n    clearClasses = () => {\r\n        const {grid} = this.state;\r\n        for(let cellRow of grid){\r\n            for(let cell of cellRow){\r\n                if(cell.isStart){\r\n                    document.getElementById(`node-${cell.row}-${cell.col}`).className ='node node-start';\r\n                }else if(cell.isFinish){\r\n                    document.getElementById(`node-${cell.row}-${cell.col}`).className ='node node-finish';\r\n                }else if(cell.isWall){\r\n                    document.getElementById(`node-${cell.row}-${cell.col}`).className ='node node-wall';\r\n                }else{\r\n                    document.getElementById(`node-${cell.row}-${cell.col}`).className ='node';\r\n                }\r\n            }\r\n        }\r\n    }\r\n    clearMaze = () => {\r\n        const {grid} = this.state;\r\n        const newGrid = grid;\r\n        this.clearClasses();\r\n        for(let cellRow of newGrid){\r\n            for(let cell of cellRow){\r\n                cell.isWall = false;\r\n            }\r\n        }\r\n        this.setState({grid: newGrid});\r\n    }\r\n    /* ------------------- */\r\n\r\n    /* Draws walls */\r\n    handleMouseDown = (row, col) => {\r\n        const {grid, solvedClass} = this.state;\r\n        if(solvedClass){\r\n            this.clearClasses();\r\n            this.setState({solvedClass: false});\r\n        }\r\n        let results = helperHandleMouseDown(row, col, grid);\r\n        this.setState({\r\n            grid: results.grid,\r\n            mouseIsPressed: results.mouseIsPressed\r\n        });\r\n    }\r\n    handleMouseEnter = (row, col) => {\r\n        const {grid, mouseIsPressed} = this.state;\r\n        this.setState({grid: helperHandleMouseEnter(row, col, grid, mouseIsPressed)});\r\n    }\r\n    handleMouseUp = () => {\r\n        this.setState({mouseIsPressed: false});\r\n    }\r\n    /* ----------------------- */\r\n\r\n    changeSolver = (newSolverId) => {\r\n        const {Solvers} = this.props;\r\n        this.setState({\r\n            selectedSolverId: newSolverId,\r\n            selectedSolver: Solvers[newSolverId]\r\n        });\r\n    }\r\n\r\n    render() {\r\n        const {grid, selectedSolverId, selectedSolver} = this.state;\r\n        const {Solvers} = this.props;\r\n        return (\r\n            <>\r\n                <div className=\"choices\">\r\n                    <Menu \r\n                        MenuName={\"Select Solver!\"} \r\n                        Options={Solvers} \r\n                        SelectedIndex={selectedSolverId}\r\n                        changeSelectedOption={this.changeSolver} />\r\n                    <Button variant=\"contained\" color=\"primary\" onClick={this.solveMaze}>Solve With <i style={{marginLeft: 5 + 'px'}}>{selectedSolver}!</i></Button>\r\n                    <Button variant=\"contained\" color=\"primary\" onClick={this.createMaze}>Generate Maze</Button>\r\n                    <Button variant=\"contained\" color=\"primary\" onClick={this.clearMaze}>Clear Maze</Button>\r\n                </div>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const {row, col, isFinish, isStart, isWall} = node;\r\n                                    return (\r\n                                        <Cell\r\n                                            key={nodeIdx}\r\n                                            col={col}\r\n                                            isFinish={isFinish}\r\n                                            isStart={isStart}\r\n                                            isWall={isWall}\r\n                                            row={row}\r\n                                            onMouseDown={this.handleMouseDown}\r\n                                            onMouseEnter={this.handleMouseEnter}\r\n                                            onMouseUp={this.handleMouseUp} />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Maze;","import {dijkstra, getDijkstraNodesInShortestPathOrder} from '../../Solvers/Dijkstra/Dijkstra';\r\nimport {astar} from '../../Solvers/AstarSearch/AstarSearch';\r\n\r\nexport function getSolvedMazePath(grid, start, finish, solver){\r\n    let visistedNodes;\r\n    let shortestPath;\r\n    let nodeVisisted_finish;\r\n    switch(solver){\r\n        // Dijkstra\r\n        case 'Dijkstra':\r\n            nodeVisisted_finish = dijkstra(grid, start, finish);\r\n            visistedNodes = nodeVisisted_finish[0];\r\n            shortestPath = getDijkstraNodesInShortestPathOrder(nodeVisisted_finish[1]);\r\n            return {\r\n                visistedNodes: visistedNodes,\r\n                shortestPath: shortestPath\r\n            }\r\n        // A* Search\r\n        case 'A* Search':\r\n            nodeVisisted_finish = astar(grid, start, finish);\r\n            visistedNodes = nodeVisisted_finish[0];\r\n            shortestPath = getDijkstraNodesInShortestPathOrder(nodeVisisted_finish[1]);\r\n            return {\r\n                visistedNodes: visistedNodes,\r\n                shortestPath: shortestPath\r\n            }\r\n        default:\r\n            visistedNodes = [];\r\n            shortestPath = [];\r\n    }\r\n}\r\n","import React, {Component} from 'react';\r\nimport Header from '../../Components/Header';\r\nimport Maze from '../../Components/Maze';\r\n\r\nclass Home extends Component {\r\n    \r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            solvers: [\r\n                \"Dijkstra\",\r\n                \"A* Search\"\r\n            ]\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const {solvers} = this.state;\r\n        return (\r\n            <>\r\n                <Header \r\n                    Title={\"Maze Solver\"} />\r\n                <Maze Solvers={solvers} />\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Home;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport Home from './Views/Home';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n        <Home />,\r\n    document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}